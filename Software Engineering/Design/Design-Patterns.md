## Task 1: Apply and Compare Creational Design Patterns

**Description:**  
Choose a real-world software scenario and implement simplified versions of the following three design patterns:

1. **Singleton Pattern** – Implement a logger class that ensures only one instance exists across the system.
2. **Factory Pattern** – Create a shape factory that returns different shape objects (e.g., Circle, Square) based on user input.
3. **Builder Pattern** – Build a `UserProfile` object step-by-step with optional fields like email, phone number, and address.

After implementing, write a short comparison (5–6 lines) highlighting:
- When each pattern is appropriate
- Which one was easiest to implement and why

**Objective:**  
Gain hands-on experience with creational design patterns and reflect on their structure, use cases, and trade-offs.

## Task 2: Implement and Reflect on Structural Design Patterns

**Description:**  
Choose **two out of the three** structural patterns discussed this week (Adapter, Composite, Decorator) and implement a simple Java/Python example for each.

Examples to inspire you:
- **Adapter:** Create a media player that supports multiple formats by adapting legacy format classes.
- **Composite:** Design a file system where files and folders are treated uniformly using a common interface.
- **Decorator:** Implement a text editor where formatting (bold, italic, underline) can be dynamically added to text without altering the base class.

**Deliverables:**
- A short paragraph (3–4 lines) explaining the problem you solved with each pattern
- Java/Python source code for each implementation
- 1–2 lines explaining why the chosen pattern was appropriate

**Objective:**  
Understand how structural patterns promote flexibility and extensibility in object-oriented design.

